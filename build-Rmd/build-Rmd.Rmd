---
title: ""
author: "Dereck de MÃ©zquita"
date: "`r format(Sys.time(), '%d %B, %Y')`"
knit: (function(inputFile, encoding) { 
      rmarkdown::render(inputFile,
                        encoding=encoding, 
                        output_file=file.path(dirname(inputFile), "./build/", "/cs-bash.html")) })
output:
  html_document:
    css: "styles.css"
    fig_caption: yes
    keep_md: yes
    number_sections: yes
    toc: yes
    # code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# cs-R

Advanced features of R, things I've learned, notes, templates, and benchmarks. In this course I include things I learned during package development.

## Useful syntax

Here is some code and syntax I found myself using and re-using.

### Better stringr interpolation

```{r}
how_long <- "very long"
paste('This is a', how_long, 'string...', sep = " ")
```

```{r}
how_long <- "very long"
stringr::str_interp('This is a ${how_long} string...')
```

```{r}
for (i in seq_along(iris[,-ncol(iris)])) {
    print(stringr::str_interp('The mean for the column ${colnames(iris)[i]} is: ${round(mean(iris[,i]), 5)}'))
}
```

### Better loops

```{r}
separate_species <- vector(mode = "list", length = length(unique(iris$Species)))
for (i in seq_along(unique(iris$Species))) {
    separate_species[[i]] <- iris[as.character(iris$Species) == as.character(unique(iris$Species)[i]), -ncol(iris)]
    
    max_val <- max(separate_species[[i]])
    print(max_val)
}
```

```{r}
max_val

i
```


```{r}
species_names <- as.character(unique(iris$Species))
names(species_names) <- species_names

apply_sep <- lapply(species_names, function(species_names) {
    species <- iris[iris$Species == species_names, -ncol(iris)]
    print(max(species))
    return(species)
})
```

#### Proof it's better

Let's benchmark these two methods. Applies also work over `data.frames`, use all applies for going over columns, and `apply` with a margin of `1` for going over rows.

Let's start by simulating some data.

##### ncol 10k nrow 40

```{r}
generated_data <- (function(offset_min, offset_max, num_cols, num_samples) {
   generated_data <- list(
        subject_a = replicate(n = num_samples, expr = runif(n = num_cols, min = 10, max = 15), simplify = "data.frame"),
        subject_b = replicate(n = num_samples, expr = runif(n = num_cols, min = 10 + offset_min, max = 15 + offset_max), simplify = "data.frame")
    )
    
    generated_data <- mapply(function(data, group_name) { # this is a multivariate apply
        data <- as.data.frame(t(data))
        colnames(data) <- paste(rep("gene", ncol(data)), 1:ncol(data), sep = "_")
        data$subject <- group_name
        data$condition <- "control"
        return(data[,c("subject", "condition", setdiff(colnames(data), c("subject", "condition")))])
    }, generated_data, names(generated_data), SIMPLIFY = FALSE)
    
    bound_data <- do.call("rbind", unname(generated_data))
    
    bound_data$subject <- make.names(bound_data$subject, unique = TRUE)
    
    bound_data[((nrow(bound_data) / 2) + 1):nrow(bound_data),]$condition <- "test"
    return(bound_data)
})(100, 150, num_cols = 10000, num_samples = 40)

# let's save this for later
data.table::fwrite(generated_data, "./data/generated-data.csv")
```

```{r}
generateData <- function(offset_min, offset_max, num_cols, num_samples) {
   generated_data <- list(
        subject_a = replicate(n = num_samples, expr = runif(n = num_cols, min = 10, max = 15), simplify = "data.frame"),
        subject_b = replicate(n = num_samples, expr = runif(n = num_cols, min = 10 + offset_min, max = 15 + offset_max), simplify = "data.frame")
    )
    
    generated_data <- mapply(function(data, group_name) { # this is a multivariate apply
        data <- as.data.frame(t(data))
        colnames(data) <- paste(rep("gene", ncol(data)), 1:ncol(data), sep = "_")
        data$subject <- group_name
        data$condition <- "control"
        return(data[,c("subject", "condition", setdiff(colnames(data), c("subject", "condition")))])
    }, generated_data, names(generated_data), SIMPLIFY = FALSE)
    
    bound_data <- do.call("rbind", unname(generated_data))
    
    bound_data$subject <- make.names(bound_data$subject, unique = TRUE)
    
    bound_data[((nrow(bound_data) / 2) + 1):nrow(bound_data),]$condition <- "test"
    return(bound_data)
}
```

Let's do a simple t-test a relatively simple operation.

```{r}
head(generated_data[, 1:5])
tail(generated_data[, 1:5])
dim(generated_data)
```

```{r}
for_vs_lapply <- microbenchmark::microbenchmark(
    for_loop_uninitialised = ({
        results <- vector()
        for (i in 1:(ncol(generated_data) - 2)) {
            results[i] <- t.test(
                generated_data[, -c(1, 2)][generated_data$condition == "control", i],
                generated_data[, -c(1, 2)][generated_data$condition == "test", i],
                var.equal = TRUE
            )$p.value
        }
    }),
    for_loop_initialised = ({
        results <- vector(mode = "list", length = (ncol(generated_data) - 2))
        for (i in 1:(ncol(generated_data) - 2)) {
            results[i] <- t.test(
                generated_data[, -c(1, 2)][generated_data$condition == "control", i],
                generated_data[, -c(1, 2)][generated_data$condition == "test", i],
                var.equal = TRUE
            )$p.value
        }
    }),
    lapply_loop = ({
        lapply(generated_data[,-c(1, 2)], function(column) {
            # print(data)
            t.test(
                column[generated_data$condition == "control"],
                column[generated_data$condition == "test"],
                var.equal = TRUE
            )$p.value
        })
    }),
    future_lapply = ({
        future::plan(strategy = "multisession", workers = future::availableCores())
        future.apply::future_lapply(generated_data[,-c(1, 2)], function(column) {
            t.test(
                column[generated_data$condition == "control"],
                column[generated_data$condition == "test"],
                var.equal = TRUE
            )$p.value
        })
    }),
    times = 3
)

ggplot2::autoplot(for_vs_lapply)
```

Consider the shape of your data, how many subjects how many observations? 

##### ncol 10k nrow 1.5k

```{r}
generated_data <- generateData(100, 150, num_cols = 7500, num_samples = 1500)
```

Let's do a simple t-test a relatively simple operation.

```{r}
head(generated_data[, 1:5])
tail(generated_data[, 1:5])
dim(generated_data)
```

```{r}
for_vs_lapply <- microbenchmark::microbenchmark(
    for_loop_uninitialised = ({
        results <- vector()
        for (i in 1:(ncol(generated_data) - 2)) {
            results[i] <- t.test(
                generated_data[, -c(1, 2)][generated_data$condition == "control", i],
                generated_data[, -c(1, 2)][generated_data$condition == "test", i],
                var.equal = TRUE
            )$p.value
        }
    }),
    for_loop_initialised = ({
        results <- vector(mode = "list", length = (ncol(generated_data) - 2))
        for (i in 1:(ncol(generated_data) - 2)) {
            results[i] <- t.test(
                generated_data[, -c(1, 2)][generated_data$condition == "control", i],
                generated_data[, -c(1, 2)][generated_data$condition == "test", i],
                var.equal = TRUE
            )$p.value
        }
    }),
    lapply_loop = ({
        lapply(generated_data[,-c(1, 2)], function(column) {
            # print(data)
            t.test(
                column[generated_data$condition == "control"],
                column[generated_data$condition == "test"],
                var.equal = TRUE
            )$p.value
        })
    }),
    future_lapply = ({
        future::plan(strategy = "multisession", workers = future::availableCores())
        future.apply::future_lapply(generated_data[,-c(1, 2)], function(column) {
            t.test(
                column[generated_data$condition == "control"],
                column[generated_data$condition == "test"],
                var.equal = TRUE
            )$p.value
        })
    }),
    times = 3
)

ggplot2::autoplot(for_vs_lapply)
```

### Messaging and printing in future applies

```{r}
generated_data <- generateData(100, 150, num_cols = 5, num_samples = 10)
```

```{r}
invisible(mapply(function(column, column_name) {
    message(stringr::str_interp('We are on this column: ${column_name}'))
    t.test(
        column[generated_data$condition == "control"],
        column[generated_data$condition == "test"],
        var.equal = TRUE
    )$p.value
}, generated_data[,-c(1, 2)], names(generated_data[,-c(1, 2)]), SIMPLIFY = FALSE))
```

```{r}
future::plan(strategy = "multisession", workers = future::availableCores())
invisible(future.apply::future_mapply(function(column, column_name) {
    message(stringr::str_interp('We are on this column: ${column_name}'))
    t.test(
        column[generated_data$condition == "control"],
        column[generated_data$condition == "test"],
        var.equal = TRUE
    )$p.value
}, generated_data[,-c(1, 2)], names(generated_data[,-c(1, 2)]), SIMPLIFY = FALSE))
```

```{r}
messageParallel <- function(...) {
    system(sprintf('echo "%s"', paste0(..., collapse = "")))
}

future::plan(strategy = "multisession", workers = future::availableCores())
invisible(future.apply::future_mapply(function(column, column_name) {
    messageParallel(stringr::str_interp('We are on this column: ${column_name}'))
    t.test(
        column[generated_data$condition == "control"],
        column[generated_data$condition == "test"],
        var.equal = TRUE
    )$p.value
}, generated_data[,-c(1, 2)], names(generated_data[,-c(1, 2)]), SIMPLIFY = FALSE))
```

# Memory and efficient coding

## `data.table`

Melting data, pivot from wide to long dataset.

```{r}
df_data <- as.data.frame(tidyr::relig_income)
tib_data <- tidyr::as_tibble(tidyr::relig_income)
DT_data <- data.table::as.data.table(tidyr::relig_income) # converts data which is a data.frame to data.table *by reference*
```

```{r}
data.table::melt(DT_data, id.vars = "religion")
tidyr::pivot_longer(tib_data, -religion)
reshape2::melt(df_data, id.vars = "religion")
reshape::melt(df_data, id.vars = "religion")
```

```{r}
bench_pivoting <- microbenchmark::microbenchmark(
    dt_longer = data.table::melt(DT_data, id.vars = "religion"),
    dt_convert_longer = data.table::melt(data.table::as.data.table(df_data), id.vars = "religion"),
    dt_df_longer = data.table::melt(df_data, id.vars = "religion"),
    tidyr_longer = tidyr::pivot_longer(tib_data, -religion),
    reshape2 = reshape2::melt(df_data, id.vars = "religion"),
    reshape = reshape::melt(df_data, id.vars = "religion"),
    times = 100
)

ggplot2::autoplot(bench_pivoting) +
    ggplot2::labs(title = "Comparing pivot long format data 1000 iterations", subtitle = "data.table is memory efficient - variables by reference not copies")
```

## Reading in data

A lot of different options: `read.csv`, `read_csv`, `vroom`, `fread`. 

```{r}
reading_csv <- microbenchmark::microbenchmark(
    base_read_csv = ({data <- read.csv("./data/generated-data.csv")}),
    datatable_fread = ({data <- data.table::fread("./data/generated-data.csv")}),
    readr_read_csv = ({data <- readr::read_csv("./data/generated-data.csv")}),
    vroom_read_csv = ({data <- vroom::vroom("./data/generated-data.csv")}),
    times = 3
)

ggplot2::autoplot(reading_csv)
```

## Writing data

```{r}
read_in_data <- data.table::fread("./data/generated-data.csv")

writing_csv <- microbenchmark::microbenchmark(
    base_write_csv = ({write.csv(read_in_data, "./data/write-test-generated-data.csv")}),
    datatable_fwrite = ({data.table::fwrite(read_in_data, "./data/write-test-generated-data.csv")}),
    times = 3
)

ggplot2::autoplot(writing_csv)
```

## Data structures and manipulation

### Object sizing

Matrices are better than data.frames. Consider the shape of your data, do you have a large number of columns?

```{r}
m <- matrix(1:400000, 200000, 2)
d <- data.frame(m)

object.size(m)
object.size(d)

dim(m)
```


```{r}
m <- matrix(1:400000, 2, 200000)
d <- data.frame(m)
object.size(m)
object.size(d)

dim(m)
```

### Matching rows across list to merge

```{r}
list_gen_data <- list(
    generated_data1 = generateData(1, 2, num_cols = 3, num_samples = 7),
    generated_data2 = generateData(1, 3, num_cols = 3, num_samples = 7)
)

list_gen_data <- lapply(list_gen_data, function(data) {
    rownames(data) <- data$subject
    return(data[,-c(1, 2)])
})

list_gen_data$generated_data1 <- list_gen_data$generated_data1[order(list_gen_data$generated_data1$gene_1),]
list_gen_data$generated_data2 <- list_gen_data$generated_data2[order(list_gen_data$generated_data2$gene_2),]
```

Re-order and merge?

```{r}
list_gen_data <- lapply(list_gen_data, function(list_item) {
    list_item[order(rownames(list_item)),]
})

do.call("cbind", unname(list_gen_data))
```

```{r}
cbindMatchList <- function(df_list) {
    return(do.call("cbind", lapply(unname(df_list), function(index) {
        if(Reduce(function(...) {
            identical(...)
        }, lapply(df_list, "rownames"))) {
            return(index[match(rownames(df_list[[1]]), rownames(index)),])
        } else {
            stop('Your rownames could not be matched across the whole list.')
        }
    })))
}
```

```{r}
cbindMatchList(list_gen_data)
```

All this chunk is doing is returning your list of `data.frames` but with `rownames` in matching order. If there is a mismatch somewhere, an error is thrown.

```{r}
lapply(unname(list_gen_data), function(index) {
    if (Reduce(function(...) {
        identical(...)
    }, lapply(list_gen_data, "rownames"))) {
        return(index[match(rownames(list_gen_data[[1]]), rownames(index)), ])
    } else {
        stop('Your rownames could not be matched across the whole list.')
    }
})
```

This is where the matching `rownames` are checked.

```{r}
list_rownames <- lapply(list_gen_data, "rownames")
list_rownames
```

```{r}
Reduce(function(...) {
    identical(...)
}, list_rownames)

identical(list_rownames$generated_data1, list_rownames$generated_data2)
```

# Session info

```{r}
sessionInfo()
```
